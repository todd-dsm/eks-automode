# Traefik Configuration for EKS with Gateway API
# Optimized for AWS environment with NLB and ACM certificate integration
# Compatible with EKS cluster version 1.32 and Traefik v3.x

# Global configuration
global:
  checkNewVersion: true
  sendAnonymousUsage: true

# Deployment configuration (replicas set via Terraform)
deployment:
  enabled: true
  kind: Deployment
  
  # Resource configuration
  resources:
    requests:
      cpu: 100m
      memory: 128Mi
    # limits set via Terraform based on environment

# Service Account for IRSA (will be annotated via Terraform)
serviceAccount:
  create: true
  name: "traefik"
  annotations: {}  # Will be set via Terraform

# Pod Security Context
podSecurityContext:
  fsGroup: 65532
  runAsGroup: 65532
  runAsNonRoot: true
  runAsUser: 65532

# Container Security Context
securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop: ["ALL"]
  readOnlyRootFilesystem: true

# Entry Points Configuration
ports:
  # Web (HTTP) - redirects to HTTPS
  web:
    port: 8080
    protocol: TCP
    expose: true
    exposedPort: 80
    redirectTo:
      port: websecure
      scheme: https
      permanent: true
  
  # Web Secure (HTTPS)
  websecure:
    port: 8443
    protocol: TCP
    expose: true
    exposedPort: 443
    tls:
      enabled: true
  
  # Traefik Dashboard
  traefik:
    port: 9000
    protocol: TCP
    expose: false

# Service Configuration - Use NodePort for NLB
service:
  enabled: true
  type: NodePort
  annotations:
    # NLB Configuration
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"
    
    # SSL Configuration (certificate ARN set via Terraform)
    service.beta.kubernetes.io/aws-load-balancer-ssl-ports: "443"
    service.beta.kubernetes.io/aws-load-balancer-ssl-negotiation-policy: "ELBSecurityPolicy-TLS13-1-2-2021-06"
    
    # Health check configuration
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-protocol: "tcp"
    service.beta.kubernetes.io/aws-load-balancer-healthcheck-port: "8080"
    
    # Additional NLB settings
    service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "instance"
    service.beta.kubernetes.io/aws-load-balancer-manage-backend-security-group-rules: "true"

# API Configuration - Enable Gateway API provider
providers:
  kubernetesCRD:
    enabled: true
    allowCrossNamespace: true
    allowExternalNameServices: true
  
  kubernetesGateway:
    enabled: true
    allowCrossNamespace: true
    allowExternalNameServices: true

# Enable Gateway API support
gatewayAPI:
  enabled: true

# Logs Configuration
logs:
  general:
    level: INFO
    format: json
  access:
    enabled: true
    format: json
    fields:
      general:
        defaultmode: keep
        names:
          StartUTC: drop
      headers:
        defaultmode: drop

# Metrics Configuration
metrics:
  prometheus:
    enabled: true
    addEntryPointsLabels: true
    addServicesLabels: true
    addRoutersLabels: true
    buckets:
      - 0.1
      - 0.3
      - 1.2
      - 5.0
  
  # ServiceMonitor for Prometheus Operator
  serviceMonitor:
    enabled: false  # Enable when Prometheus is deployed
    interval: 30s

# Dashboard Configuration
api:
  enabled: true
  dashboard: true
  debug: false
  insecure: false  # Use HTTPS for dashboard

# Disable ping service (use health endpoint instead)
ping:
  enabled: false

# Health check configuration
healthcheck:
  enabled: true

# Pilot telemetry (disabled for privacy)
pilot:
  enabled: false

# Experimental features
experimental:
  plugins:
    enabled: false

# Additional arguments
additionalArguments:
  # Gateway API configuration
  - "--providers.kubernetesgateway=true"
  - "--providers.kubernetesgateway.allowCrossNamespace=true"
  - "--providers.kubernetesgateway.allowExternalNameServices=true"
  
  # Certificate resolvers (ACME disabled as we use ACM)
  - "--certificatesresolvers.letsencrypt.acme.tlschallenge=false"
  
  # Enable API
  - "--api=true"
  - "--api.dashboard=true"
  - "--api.insecure=false"
  
  # Tracing (optional)
  - "--tracing=false"

# Environment variables
env:
  - name: POD_NAME
    valueFrom:
      fieldRef:
        fieldPath: metadata.name
  - name: POD_NAMESPACE
    valueFrom:
      fieldRef:
        fieldPath: metadata.namespace

# Node selector for scheduling
nodeSelector:
  kubernetes.io/os: linux

# Tolerations
tolerations: []

# Affinity rules for high availability
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
    - weight: 100
      podAffinityTerm:
        labelSelector:
          matchExpressions:
          - key: app.kubernetes.io/name
            operator: In
            values:
            - traefik
        topologyKey: kubernetes.io/hostname

# Persistence (disabled as we don't need persistent storage)
persistence:
  enabled: false

# Additional volumes for certificates (if needed)
volumes: []

# Additional volume mounts
volumeMounts: []

# Horizontal Pod Autoscaler (enabled/disabled via Terraform)
autoscaling:
  enabled: false  # Set via Terraform based on environment
  # minReplicas/maxReplicas set via Terraform
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Enable readiness and liveness probes
readinessProbe:
  httpGet:
    path: /ping
    port: 9000
  initialDelaySeconds: 2
  periodSeconds: 10

livenessProbe:
  httpGet:
    path: /ping
    port: 9000
  initialDelaySeconds: 10
  periodSeconds: 10name
            operator: In
            values:
            - traefik
        topologyKey: kubernetes.io/hostname

# Persistence (disabled as we don't need persistent storage)
persistence:
  enabled: false

# Additional volumes for certificates (if needed)
volumes: []

# Additional volume mounts
volumeMounts: []

# Horizontal Pod Autoscaler
autoscaling:
  enabled: false  # Can be enabled later if needed
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70

# Pod Disruption Budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1

# Enable readiness and liveness probes
readinessProbe:
  httpGet:
    path: /ping
    port: 9000
  initialDelaySeconds: 2
  periodSeconds: 10

livenessProbe:
  httpGet:
    path: /ping
    port: 9000
  initialDelaySeconds: 10
  periodSeconds: 10
